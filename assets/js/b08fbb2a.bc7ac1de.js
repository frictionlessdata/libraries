(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{112:function(e,t,a){"use strict";a.d(t,"a",(function(){return p})),a.d(t,"b",(function(){return u}));var n=a(0),r=a.n(n);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function b(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?b(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):b(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function c(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var o=r.a.createContext({}),s=function(e){var t=r.a.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},p=function(e){var t=s(e.components);return r.a.createElement(o.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,b=e.parentName,o=c(e,["components","mdxType","originalType","parentName"]),p=s(a),m=n,u=p["".concat(b,".").concat(m)]||p[m]||d[m]||l;return a?r.a.createElement(u,i(i({ref:t},o),{},{components:a})):r.a.createElement(u,i({ref:t},o))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,b=new Array(l);b[0]=m;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,b[1]=i;for(var o=2;o<l;o++)b[o]=a[o];return r.a.createElement.apply(null,b)}return r.a.createElement.apply(null,a)}m.displayName="MDXCreateElement"},95:function(e,t,a){"use strict";a.r(t),a.d(t,"frontMatter",(function(){return i})),a.d(t,"metadata",(function(){return c})),a.d(t,"toc",(function(){return o})),a.d(t,"default",(function(){return p}));var n=a(3),r=a(8),l=(a(0),a(112)),b=["components"],i={title:"tableschema-py"},c={unversionedId:"table-schema/python",id:"table-schema/python",isDocsHomePage:!1,title:"tableschema-py",description:"Travis",source:"@site/docs/table-schema/python.md",slug:"/table-schema/python",permalink:"/docs/table-schema/python",editUrl:"https://github.com/frictionlessdata/libraries/edit/master/docs/docs/table-schema/python.md",version:"current",lastUpdatedBy:"roll",lastUpdatedAt:1622451895,formattedLastUpdatedAt:"5/31/2021",sidebar:"table-schema",next:{title:"tableschema-js",permalink:"/docs/table-schema/javascript"}},o=[{value:"Features",id:"features",children:[]},{value:"Contents",id:"contents",children:[]},{value:"Getting Started",id:"getting-started",children:[{value:"Installation",id:"installation",children:[]}]},{value:"Documentation",id:"documentation",children:[{value:"Introduction",id:"introduction",children:[]},{value:"Working with Table",id:"working-with-table",children:[]},{value:"Working with Schema",id:"working-with-schema",children:[]},{value:"Working with Field",id:"working-with-field",children:[]}]},{value:"API Reference",id:"api-reference",children:[{value:"<code>cli</code>",id:"cli",children:[]},{value:"<code>Table</code>",id:"table",children:[]},{value:"<code>Schema</code>",id:"schema",children:[]},{value:"<code>Field</code>",id:"field",children:[]},{value:"<code>Storage</code>",id:"storage",children:[]},{value:"<code>validate</code>",id:"validate",children:[]},{value:"<code>infer</code>",id:"infer",children:[]},{value:"<code>FailedCast</code>",id:"failedcast",children:[]},{value:"<code>DataPackageException</code>",id:"datapackageexception",children:[]},{value:"<code>TableSchemaException</code>",id:"tableschemaexception",children:[]},{value:"<code>LoadError</code>",id:"loaderror",children:[]},{value:"<code>ValidationError</code>",id:"validationerror",children:[]},{value:"<code>CastError</code>",id:"casterror",children:[]},{value:"<code>IntegrityError</code>",id:"integrityerror",children:[]},{value:"<code>UniqueKeyError</code>",id:"uniquekeyerror",children:[]},{value:"<code>RelationError</code>",id:"relationerror",children:[]},{value:"<code>UnresolvedFKError</code>",id:"unresolvedfkerror",children:[]},{value:"<code>StorageError</code>",id:"storageerror",children:[]}]},{value:"Experimental",id:"experimental",children:[]},{value:"Contributing",id:"contributing",children:[]},{value:"Changelog",id:"changelog",children:[]}],s={toc:o};function p(e){var t=e.components,a=Object(r.a)(e,b);return Object(l.b)("wrapper",Object(n.a)({},s,a,{components:t,mdxType:"MDXLayout"}),Object(l.b)("p",null,Object(l.b)("a",{parentName:"p",href:"https://travis-ci.org/frictionlessdata/tableschema-py"},Object(l.b)("img",{parentName:"a",src:"https://travis-ci.org/frictionlessdata/tableschema-py.svg?branch=master",alt:"Travis"})),"\n",Object(l.b)("a",{parentName:"p",href:"https://coveralls.io/r/frictionlessdata/tableschema-py?branch=master"},Object(l.b)("img",{parentName:"a",src:"http://img.shields.io/coveralls/frictionlessdata/tableschema-py.svg?branch=master",alt:"Coveralls"})),"\n",Object(l.b)("a",{parentName:"p",href:"https://pypi.python.org/pypi/tableschema"},Object(l.b)("img",{parentName:"a",src:"https://img.shields.io/pypi/v/tableschema.svg",alt:"PyPi"})),"\n",Object(l.b)("a",{parentName:"p",href:"https://github.com/frictionlessdata/tableschema-py"},Object(l.b)("img",{parentName:"a",src:"https://img.shields.io/badge/github-master-brightgreen",alt:"Github"})),"\n",Object(l.b)("a",{parentName:"p",href:"https://gitter.im/frictionlessdata/chat"},Object(l.b)("img",{parentName:"a",src:"https://img.shields.io/gitter/room/frictionlessdata/chat.svg",alt:"Gitter"}))),Object(l.b)("p",null,"A Python implementation of the ",Object(l.b)("a",{parentName:"p",href:"http://specs.frictionlessdata.io/table-schema/"},"Table Schema")," standard."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},Object(l.b)("strong",{parentName:"p"},"[Important Notice]")," We have released ",Object(l.b)("a",{parentName:"p",href:"https://github.com/frictionlessdata/frictionless-py"},"Frictionless Framework"),". This framework provides improved ",Object(l.b)("inlineCode",{parentName:"p"},"tableschema")," functionality extended to be a complete data solution. The change in not breaking for the existing software so no actions are required. Please read the ",Object(l.b)("a",{parentName:"p",href:"https://framework.frictionlessdata.io/docs/development/migration"},"Migration Guide")," from ",Object(l.b)("inlineCode",{parentName:"p"},"tableschema")," to Frictionless Framework."),Object(l.b)("ul",{parentName:"blockquote"},Object(l.b)("li",{parentName:"ul"},"we continue to bug-fix ",Object(l.b)("inlineCode",{parentName:"li"},"tableschema@1.x")," in this ",Object(l.b)("a",{parentName:"li",href:"https://github.com/frictionlessdata/tableschema-py"},"repository")," as well as it's available on ",Object(l.b)("a",{parentName:"li",href:"https://pypi.org/project/tableschema/"},"PyPi")," as it was before"),Object(l.b)("li",{parentName:"ul"},"please note that ",Object(l.b)("inlineCode",{parentName:"li"},"frictionless@3.x")," version's API, we're working on at the moment, is not stable"),Object(l.b)("li",{parentName:"ul"},"we will release ",Object(l.b)("inlineCode",{parentName:"li"},"frictionless@4.x")," by the end of 2020 to be the first SemVer/stable version"))),Object(l.b)("h2",{id:"features"},"Features"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Table")," to work with data tables described by Table Schema"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Schema")," representing Table Schema"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"Field")," representing Table Schema field"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"validate")," to validate Table Schema"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"infer")," to infer Table Schema from data"),Object(l.b)("li",{parentName:"ul"},"built-in command-line interface to validate and infer schemas"),Object(l.b)("li",{parentName:"ul"},"storage/plugins system to connect tables to different storage backends like SQL Database")),Object(l.b)("h2",{id:"contents"},"Contents"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#getting-started"},"Getting Started"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#installation"},"Installation")))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#documentation"},"Documentation"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#introduction"},"Introduction")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#working-with-table"},"Working with Table")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#working-with-schema"},"Working with Schema")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#working-with-field"},"Working with Field")))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#api-reference"},"API Reference"),Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#cli"},Object(l.b)("inlineCode",{parentName:"a"},"cli"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#table"},Object(l.b)("inlineCode",{parentName:"a"},"Table"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#schema"},Object(l.b)("inlineCode",{parentName:"a"},"Schema"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#field"},Object(l.b)("inlineCode",{parentName:"a"},"Field"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#storage"},Object(l.b)("inlineCode",{parentName:"a"},"Storage"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#validate"},Object(l.b)("inlineCode",{parentName:"a"},"validate"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#infer"},Object(l.b)("inlineCode",{parentName:"a"},"infer"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#failedcast"},Object(l.b)("inlineCode",{parentName:"a"},"FailedCast"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#datapackageexception"},Object(l.b)("inlineCode",{parentName:"a"},"DataPackageException"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#tableschemaexception"},Object(l.b)("inlineCode",{parentName:"a"},"TableSchemaException"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#loaderror"},Object(l.b)("inlineCode",{parentName:"a"},"LoadError"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#validationerror"},Object(l.b)("inlineCode",{parentName:"a"},"ValidationError"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#casterror"},Object(l.b)("inlineCode",{parentName:"a"},"CastError"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#integrityerror"},Object(l.b)("inlineCode",{parentName:"a"},"IntegrityError"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#uniquekeyerror"},Object(l.b)("inlineCode",{parentName:"a"},"UniqueKeyError"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#relationerror"},Object(l.b)("inlineCode",{parentName:"a"},"RelationError"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#unresolvedfkerror"},Object(l.b)("inlineCode",{parentName:"a"},"UnresolvedFKError"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#storageerror"},Object(l.b)("inlineCode",{parentName:"a"},"StorageError"))))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#experimental"},"Experimental")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#contributing"},"Contributing")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("a",{parentName:"li",href:"#changelog"},"Changelog"))),Object(l.b)("h2",{id:"getting-started"},"Getting Started"),Object(l.b)("h3",{id:"installation"},"Installation"),Object(l.b)("p",null,"The package uses semantic versioning. It means that major versions  could include breaking changes. It's highly recommended to specify ",Object(l.b)("inlineCode",{parentName:"p"},"tableschema")," version range in your ",Object(l.b)("inlineCode",{parentName:"p"},"setup/requirements")," file e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"tableschema>=1.0,<2.0"),"."),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-bash"},"$ pip install tableschema\n")),Object(l.b)("h2",{id:"documentation"},"Documentation"),Object(l.b)("h3",{id:"introduction"},"Introduction"),Object(l.b)("p",null,"Let's start with a simple example:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"from tableschema import Table\n\n# Create table\ntable = Table('path.csv', schema='schema.json')\n\n# Print schema descriptor\nprint(table.schema.descriptor)\n\n# Print cast rows in a dict form\nfor keyed_row in table.iter(keyed=True):\n    print(keyed_row)\n")),Object(l.b)("h3",{id:"working-with-table"},"Working with Table"),Object(l.b)("p",null,"A table is a core concept in a tabular data world. It represents data with metadata (Table Schema). Let's see how we can use it in practice."),Object(l.b)("p",null,"Consider we have some local csv file. It could be inline data or from a remote link - all supported by the ",Object(l.b)("inlineCode",{parentName:"p"},"Table")," class (except local files for in-brower usage of course). But say it's ",Object(l.b)("inlineCode",{parentName:"p"},"data.csv")," for now:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-csv"},'city,location\nlondon,"51.50,-0.11"\nparis,"48.85,2.30"\nrome,N/A\n')),Object(l.b)("p",null,"Let's create and read a table instance. We use the static ",Object(l.b)("inlineCode",{parentName:"p"},"Table.load")," method and the ",Object(l.b)("inlineCode",{parentName:"p"},"table.read")," method with the ",Object(l.b)("inlineCode",{parentName:"p"},"keyed")," option to get an array of keyed rows:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table = Table('data.csv')\ntable.headers # ['city', 'location']\ntable.read(keyed=True)\n# [\n#   {city: 'london', location: '51.50,-0.11'},\n#   {city: 'paris', location: '48.85,2.30'},\n#   {city: 'rome', location: 'N/A'},\n# ]\n")),Object(l.b)("p",null,"As we can see, our locations are just strings. But they should be geopoints. Also, Rome's location is not available, but it's just a string ",Object(l.b)("inlineCode",{parentName:"p"},"N/A")," instead of ",Object(l.b)("inlineCode",{parentName:"p"},"None"),". First we have to infer Table Schema:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.infer()\ntable.schema.descriptor\n# { fields:\n#   [ { name: 'city', type: 'string', format: 'default' },\n#     { name: 'location', type: 'geopoint', format: 'default' } ],\n#  missingValues: [ '' ] }\ntable.read(keyed=True)\n# Fails with a data validation error\n")),Object(l.b)("p",null,'Let\'s fix the "not available" location. There is a ',Object(l.b)("inlineCode",{parentName:"p"},"missingValues")," property in Table Schema specification. As a first try we set ",Object(l.b)("inlineCode",{parentName:"p"},"missingValues")," to ",Object(l.b)("inlineCode",{parentName:"p"},"N/A")," in ",Object(l.b)("inlineCode",{parentName:"p"},"table.schema.descriptor"),". The schema descriptor can be changed in-place, but all changes should also be committed using ",Object(l.b)("inlineCode",{parentName:"p"},"table.schema.commit()"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.schema.descriptor['missingValues'] = 'N/A'\ntable.schema.commit()\ntable.schema.valid # false\ntable.schema.errors\n# [<ValidationError: \"'N/A' is not of type 'array'\">]\n")),Object(l.b)("p",null,"As a good citizens we've decided to check our schema descriptor's validity. And it's not valid! We should use an array for the ",Object(l.b)("inlineCode",{parentName:"p"},"missingValues"),' property. Also, don\'t forget to include "empty string" as a valid missing value:'),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.schema.descriptor['missingValues'] = ['', 'N/A']\ntable.schema.commit()\ntable.schema.valid # true\n")),Object(l.b)("p",null,"All good. It looks like we're ready to read our data again:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.read(keyed=True)\n# [\n#   {city: 'london', location: [51.50,-0.11]},\n#   {city: 'paris', location: [48.85,2.30]},\n#   {city: 'rome', location: null},\n# ]\n")),Object(l.b)("p",null,"Now we see that:"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"locations are arrays with numeric latitude and longitude"),Object(l.b)("li",{parentName:"ul"},"Rome's location is a native Python ",Object(l.b)("inlineCode",{parentName:"li"},"None"))),Object(l.b)("p",null,"And because there are no errors after reading, we can be sure that our data is valid against our schema. Let's save it:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.schema.save('schema.json')\ntable.save('data.csv')\n")),Object(l.b)("p",null,"Our ",Object(l.b)("inlineCode",{parentName:"p"},"data.csv")," looks the same because it has been stringified back to ",Object(l.b)("inlineCode",{parentName:"p"},"csv")," format. But now we have ",Object(l.b)("inlineCode",{parentName:"p"},"schema.json"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-json"},'{\n    "fields": [\n        {\n            "name": "city",\n            "type": "string",\n            "format": "default"\n        },\n        {\n            "name": "location",\n            "type": "geopoint",\n            "format": "default"\n        }\n    ],\n    "missingValues": [\n        "",\n        "N/A"\n    ]\n}\n\n')),Object(l.b)("p",null,"If we decide to improve it even more we could update the schema file and then open it again. But now providing a schema path:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table = Table('data.csv', schema='schema.json')\n# Continue the work\n")),Object(l.b)("p",null,"As already mentioned a given schema can be used to ",Object(l.b)("em",{parentName:"p"},"validate")," data (see the ",Object(l.b)("a",{parentName:"p",href:"#schema"},"Schema")," section for schema specification details). In default mode invalid data rows immediately trigger an ",Object(l.b)("a",{parentName:"p",href:"#exceptions"},"exception")," in the ",Object(l.b)("inlineCode",{parentName:"p"},"table.iter()"),"/",Object(l.b)("inlineCode",{parentName:"p"},"table.write()")," methods."),Object(l.b)("p",null,"Suppose this schema-invalid local file ",Object(l.b)("inlineCode",{parentName:"p"},"invalid_data.csv"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-csv"},"key,value\nzero,0\none,not_an_integer\ntwo,2\n")),Object(l.b)("p",null,"We're going to validate the data against the following schema:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table = Table(\n    'invalid_data.csv',\n    schema={'fields': [{'name': 'key'}, {'name': 'value', 'type': 'integer'}]})\n")),Object(l.b)("p",null,"Iterating over the data triggers an exception due to the failed cast of ",Object(l.b)("inlineCode",{parentName:"p"},"'not_an_integer'")," to ",Object(l.b)("inlineCode",{parentName:"p"},"int"),":"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},'for row in table.iter():\n    print(row)\n\n# Traceback (most recent call last):\n# ...\n# tableschema.exceptions.CastError: There are 1 cast errors (see exception.errors) for row "3"\n')),Object(l.b)("p",null,"Hint: The row number count starts with 1 and also includes header lines."),Object(l.b)("p",null,"(Note: You can optionally switch off ",Object(l.b)("inlineCode",{parentName:"p"},"iter()"),"/",Object(l.b)("inlineCode",{parentName:"p"},"read()")," value casting using the cast parameter, see reference below.)"),Object(l.b)("p",null,'By providing a custom exception handler (a callable) to those methods you can treat occurring exceptions at your own discretion, i.e. to "fail late" and e.g. gather a validation report on the whole data:'),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"errors = []\ndef exc_handler(exc, row_number=None, row_data=None, error_data=None):\n    errors.append((exc, row_number, row_data, error_data))\n\nfor row in table.iter(exc_handler=exc_handler):\n    print(row)\n\n# ['zero', 0]\n# ['one', FailedCast('not_an_integer')]\n# ['two', 2]\n\nprint(errors)\n\n# [(CastError('There are 1 cast errors (see exception.errors) for row \"3\"',),\n#   3,\n#   OrderedDict([('key', 'one'), ('value', 'not_an_integer')]),\n#   OrderedDict([('value', 'not_an_integer')]))]\n")),Object(l.b)("p",null,"Note that"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Data rows are yielded even though the data is schema-invalid; this is due to our custom expression handler choosing not to raise exceptions (but rather collect them in the errors list)."),Object(l.b)("li",{parentName:"ul"},"Data field values that can't get casted properly (if ",Object(l.b)("inlineCode",{parentName:"li"},"iter()"),"/",Object(l.b)("inlineCode",{parentName:"li"},"read()")," cast parameter is set to True, which is the default) are wrapped into a ",Object(l.b)("inlineCode",{parentName:"li"},"FailedCast"),' "value holder". This allows for distinguishing uncasted values from successfully casted values on the data consumer side. ',Object(l.b)("inlineCode",{parentName:"li"},"FailedCast")," instances can only get yielded when custom exception handling is in place."),Object(l.b)("li",{parentName:"ul"},"The custom exception handler callable must support a function signature as specified in the ",Object(l.b)("inlineCode",{parentName:"li"},"iter()"),"/",Object(l.b)("inlineCode",{parentName:"li"},"read()")," sections of the ",Object(l.b)("inlineCode",{parentName:"li"},"Table")," class API reference.")),Object(l.b)("h3",{id:"working-with-schema"},"Working with Schema"),Object(l.b)("p",null,"A model of a schema with helpful methods for working with the schema and supported data. Schema instances can be initialized with a schema source as a url to a JSON file or a JSON object. The schema is initially validated (see ",Object(l.b)("a",{parentName:"p",href:"#validate"},"validate")," below). By default validation errors will be stored in ",Object(l.b)("inlineCode",{parentName:"p"},"schema.errors")," but in a strict mode it will be instantly raised."),Object(l.b)("p",null,"Let's create a blank schema. It's not valid because ",Object(l.b)("inlineCode",{parentName:"p"},"descriptor.fields")," property is required by the ",Object(l.b)("a",{parentName:"p",href:"http://specs.frictionlessdata.io/table-schema/"},"Table Schema")," specification:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema = Schema()\nschema.valid # false\nschema.errors\n# [<ValidationError: \"'fields' is a required property\">]\n")),Object(l.b)("p",null,"To avoid creating a schema descriptor by hand we will use a ",Object(l.b)("inlineCode",{parentName:"p"},"schema.infer")," method to infer the descriptor from given data:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.infer([\n  ['id', 'age', 'name'],\n  ['1','39','Paul'],\n  ['2','23','Jimmy'],\n  ['3','36','Jane'],\n  ['4','28','Judy'],\n])\nschema.valid # true\nschema.descriptor\n#{ fields:\n#   [ { name: 'id', type: 'integer', format: 'default' },\n#     { name: 'age', type: 'integer', format: 'default' },\n#     { name: 'name', type: 'string', format: 'default' } ],\n#  missingValues: [ '' ] }\n")),Object(l.b)("p",null,"Now we have an inferred schema and it's valid. We can cast data rows against our schema. We provide a string input which will be cast correspondingly:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.cast_row(['5', '66', 'Sam'])\n# [ 5, 66, 'Sam' ]\n")),Object(l.b)("p",null,"But if we try provide some missing value to the ",Object(l.b)("inlineCode",{parentName:"p"},"age"),' field, the cast will fail because the only valid "missing" value is an empty string. Let\'s update our schema:'),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.cast_row(['6', 'N/A', 'Walt'])\n# Cast error\nschema.descriptor['missingValues'] = ['', 'N/A']\nschema.commit()\nschema.cast_row(['6', 'N/A', 'Walt'])\n# [ 6, None, 'Walt' ]\n")),Object(l.b)("p",null,"We can save the schema to a local file, and resume work on it at any time by loading it from that file:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.save('schema.json')\nschema = Schema('schema.json')\n")),Object(l.b)("h3",{id:"working-with-field"},"Working with Field"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"from tableschema import Field\n\n# Init field\nfield = Field({'name': 'name', 'type': 'number'})\n\n# Cast a value\nfield.cast_value('12345') # -> 12345\n")),Object(l.b)("p",null,"Data values can be cast to native Python objects with a Field instance. Type instances can be initialized with ",Object(l.b)("a",{parentName:"p",href:"https://specs.frictionlessdata.io/table-schema/"},"field descriptors"),". This allows formats and constraints to be defined."),Object(l.b)("p",null,"Casting a value will check the value is of the expected type, is in the correct format, and complies with any constraints imposed by a schema. E.g. a date value (in ISO 8601 format) can be cast with a DateType instance. Values that can't be cast will raise an ",Object(l.b)("inlineCode",{parentName:"p"},"InvalidCastError")," exception."),Object(l.b)("p",null,"Casting a value that doesn't meet the constraints will raise a ",Object(l.b)("inlineCode",{parentName:"p"},"ConstraintError")," exception."),Object(l.b)("h2",{id:"api-reference"},"API Reference"),Object(l.b)("h3",{id:"cli"},Object(l.b)("inlineCode",{parentName:"h3"},"cli")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"cli()\n")),Object(l.b)("p",null,"Command-line interface"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"Usage: tableschema [OPTIONS] COMMAND [ARGS]...\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  infer     Infer a schema from data.\n  info      Return info on this version of Table Schema\n  validate  Validate that a supposed schema is in fact a Table Schema.\n")),Object(l.b)("h3",{id:"table"},Object(l.b)("inlineCode",{parentName:"h3"},"Table")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"Table(self,\n      source,\n      schema=None,\n      strict=False,\n      post_cast=[],\n      storage=None,\n      **options)\n")),Object(l.b)("p",null,"Table representation"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"source (str/list[])"),": data source one of:",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},"local file (path)"),Object(l.b)("li",{parentName:"ul"},"remote file (url)"),Object(l.b)("li",{parentName:"ul"},"array of arrays representing the rows"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"schema (any)"),": data schema in all forms supported by ",Object(l.b)("inlineCode",{parentName:"li"},"Schema")," class"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"strict (bool)"),": strictness option to pass to ",Object(l.b)("inlineCode",{parentName:"li"},"Schema")," constructor"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"post_cast (function[])"),": list of post cast processors"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"storage (None)"),": storage name like ",Object(l.b)("inlineCode",{parentName:"li"},"sql")," or ",Object(l.b)("inlineCode",{parentName:"li"},"bigquery")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"options (dict)"),": ",Object(l.b)("inlineCode",{parentName:"li"},"tabulator")," or storage's options")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises on any error")),Object(l.b)("h4",{id:"tablehash"},Object(l.b)("inlineCode",{parentName:"h4"},"table.hash")),Object(l.b)("p",null,"Table's SHA256 hash if it's available."),Object(l.b)("p",null,"If it's already read using e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"table.read"),", otherwise returns ",Object(l.b)("inlineCode",{parentName:"p"},"None"),".\nIn the middle of an iteration it returns hash of already read contents"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str/None"),": SHA256 hash"),Object(l.b)("h4",{id:"tableheaders"},Object(l.b)("inlineCode",{parentName:"h4"},"table.headers")),Object(l.b)("p",null,"Table's headers is available"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str[]"),": headers"),Object(l.b)("h4",{id:"tableschema"},Object(l.b)("inlineCode",{parentName:"h4"},"table.schema")),Object(l.b)("p",null,"Returns schema class instance if available"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Schema"),": schema"),Object(l.b)("h4",{id:"tablesize"},Object(l.b)("inlineCode",{parentName:"h4"},"table.size")),Object(l.b)("p",null,"Table's size in BYTES if it's available"),Object(l.b)("p",null,"If it's already read using e.g. ",Object(l.b)("inlineCode",{parentName:"p"},"table.read"),", otherwise returns ",Object(l.b)("inlineCode",{parentName:"p"},"None"),".\nIn the middle of an iteration it returns size of already read contents"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"int/None"),": size in BYTES"),Object(l.b)("h4",{id:"tableiter"},Object(l.b)("inlineCode",{parentName:"h4"},"table.iter")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.iter(keyed=False,\n           extended=False,\n           cast=True,\n           integrity=False,\n           relations=False,\n           foreign_keys_values=False,\n           exc_handler=None)\n")),Object(l.b)("p",null,"Iterates through the table data and emits rows cast based on table schema."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre"},"keyed (bool):\n    yield keyed rows in a form of `{header1: value1, header2: value2}`\n    (default is false; the form of rows is `[value1, value2]`)\n\nextended (bool):\n    yield extended rows in a for of `[rowNumber, [header1, header2], [value1, value2]]`\n    (default is false; the form of rows is `[value1, value2]`)\n\ncast (bool):\n    disable data casting if false\n    (default is true)\n\nintegrity (dict):\n    dictionary in a form of `{'size': <bytes>, 'hash': '<sha256>'}`\n    to check integrity of the table when it's read completely.\n    Both keys are optional.\n\nrelations (dict):\n    dictionary of foreign key references in a form\n    of `{resource1: [{field1: value1, field2: value2}, ...], ...}`.\n    If provided, foreign key fields will checked and resolved\n    to one of their references (/!\\ one-to-many fk are not completely resolved).\n\nforeign_keys_values (dict):\n    three-level dictionary of foreign key references optimized\n    to speed up validation process in a form of\n    `{resource1: {(fk_field1, fk_field2): {(value1, value2): {one_keyedrow}, ... }}}`.\n    If not provided but relations is true, it will be created\n    before the validation process by *index_foreign_keys_values* method\n\nexc_handler (func):\n    optional custom exception handler callable.\n    Can be used to defer raising errors (i.e. \"fail late\"), e.g.\n    for data validation purposes. Must support the signature below\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Custom exception handler")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"def exc_handler(exc, row_number=None, row_data=None, error_data=None):\n    '''Custom exception handler (example)\n\n    # Arguments:\n        exc(Exception):\n            Deferred exception instance\n        row_number(int):\n            Data row number that triggers exception exc\n        row_data(OrderedDict):\n            Invalid data row source data\n        error_data(OrderedDict):\n            Data row source data field subset responsible for the error, if\n            applicable (e.g. invalid primary or foreign key fields). May be\n            identical to row_data.\n    '''\n    # ...\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": base class of any error"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"CastError"),": data cast error"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"IntegrityError"),": integrity checking error"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"UniqueKeyError"),": unique key constraint violation"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"UnresolvedFKError"),": unresolved foreign key reference error")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Iterator[list]"),": yields rows"),Object(l.b)("h4",{id:"tableread"},Object(l.b)("inlineCode",{parentName:"h4"},"table.read")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.read(keyed=False,\n           extended=False,\n           cast=True,\n           limit=None,\n           integrity=False,\n           relations=False,\n           foreign_keys_values=False,\n           exc_handler=None)\n")),Object(l.b)("p",null,"Read the whole table and return as array of rows"),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"It has the same API as ",Object(l.b)("inlineCode",{parentName:"p"},"table.iter")," except for")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"limit (int)"),": limit count of rows to read and return")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"list[]"),": returns rows"),Object(l.b)("h4",{id:"tableinfer"},Object(l.b)("inlineCode",{parentName:"h4"},"table.infer")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.infer(limit=100,\n            confidence=0.75,\n            missing_values=[''],\n            guesser_cls=None,\n            resolver_cls=None)\n")),Object(l.b)("p",null,"Infer a schema for the table."),Object(l.b)("p",null,"It will infer and set Table Schema to ",Object(l.b)("inlineCode",{parentName:"p"},"table.schema")," based on table data."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"limit (int)"),": limit rows sample size"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"confidence (float)"),": how many casting errors are allowed (as a ratio, between 0 and 1)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"missing_values (str[])"),": list of missing values (by default ",Object(l.b)("inlineCode",{parentName:"li"},"['']"),")"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"guesser_cls (class)"),": you can implement inferring strategies by\nproviding type-guessing and type-resolving classes ","[experimental]"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"resolver_cls (class)"),": you can implement inferring strategies by\nproviding type-guessing and type-resolving classes ","[experimental]")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict"),": Table Schema descriptor"),Object(l.b)("h4",{id:"tablesave"},Object(l.b)("inlineCode",{parentName:"h4"},"table.save")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.save(target, storage=None, **options)\n")),Object(l.b)("p",null,"Save data source to file locally in CSV format with ",Object(l.b)("inlineCode",{parentName:"p"},",")," (comma) delimiter"),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"To save schema use ",Object(l.b)("inlineCode",{parentName:"p"},"table.schema.save()"))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"target (str)"),": saving target (e.g. file path)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"storage (None/str)"),": storage name like ",Object(l.b)("inlineCode",{parentName:"li"},"sql")," or ",Object(l.b)("inlineCode",{parentName:"li"},"bigquery")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"options (dict)"),": ",Object(l.b)("inlineCode",{parentName:"li"},"tabulator")," or storage options")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises an error if there is saving problem")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"True/Storage"),": returns true or storage instance"),Object(l.b)("h4",{id:"tableindex_foreign_keys_values"},Object(l.b)("inlineCode",{parentName:"h4"},"table.index_foreign_keys_values")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"table.index_foreign_keys_values(relations)\n")),Object(l.b)("p",null,"Creates a three-level dictionary of foreign key references"),Object(l.b)("p",null,"We create them optimized to speed up validation process in a form of\n",Object(l.b)("inlineCode",{parentName:"p"},"{resource1: {(fk_field1, fk_field2): {(value1, value2): {one_keyedrow}, ... }}}"),"."),Object(l.b)("p",null,"For each foreign key of the schema it will iterate through the corresponding\n",Object(l.b)("inlineCode",{parentName:"p"},"relations['resource']")," to create an index (i.e. a dict) of existing values\nfor the foreign fields and store on keyed row for each value combination."),Object(l.b)("p",null,"The optimization relies on the indexation of possible values for one foreign key\nin a hashmap to later speed up resolution."),Object(l.b)("p",null,"This method is public to allow creating the index once to apply it\non multiple tables charing the same schema\n(typically ",Object(l.b)("a",{parentName:"p",href:"https://github.com/frictionlessdata/datapackage-py#group"},"grouped resources in datapackage"),")"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Notes")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"the second key of the output is a tuple of the foreign fields,\na proxy identifier of the foreign key"),Object(l.b)("li",{parentName:"ul"},"the same relation resource can be indexed multiple times\nas a schema can contain more than one Foreign Keys\npointing to the same resource")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"relations (dict)"),":\ndict of foreign key references in a form of\n",Object(l.b)("inlineCode",{parentName:"li"},"{resource1: [{field1: value1, field2: value2}, ...], ...}"),".\nIt must contain all resources pointed in the foreign keys schema definition.")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict"),":\nreturns a three-level dictionary of foreign key references\noptimized to speed up validation process in a form of\n",Object(l.b)("inlineCode",{parentName:"p"},"{resource1: {(fk_field1, fk_field2): {(value1, value2): {one_keyedrow}, ... }}})")),Object(l.b)("h3",{id:"schema"},Object(l.b)("inlineCode",{parentName:"h3"},"Schema")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"Schema(self, descriptor={}, strict=False)\n")),Object(l.b)("p",null,"Schema representation"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"descriptor (str/dict)"),": schema descriptor one of:",Object(l.b)("pre",{parentName:"li"},Object(l.b)("code",{parentName:"pre"},"  - local path\n  - remote url\n  - dictionary\n"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"strict (bool)"),": flag to specify validation behaviour:",Object(l.b)("pre",{parentName:"li"},Object(l.b)("code",{parentName:"pre"},"  - if false, errors will not be raised but instead collected in `schema.errors`\n  - if true, validation errors are raised immediately\n")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raise any error that occurs during the process")),Object(l.b)("h4",{id:"schemadescriptor"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.descriptor")),Object(l.b)("p",null,"Schema's descriptor"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict"),": descriptor"),Object(l.b)("h4",{id:"schemaerrors"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.errors")),Object(l.b)("p",null,"Validation errors"),Object(l.b)("p",null,"Always empty in strict mode."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Exception[]"),": validation errors"),Object(l.b)("h4",{id:"schemafield_names"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.field_names")),Object(l.b)("p",null,"Schema's field names"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str[]"),": an array of field names"),Object(l.b)("h4",{id:"schemafields"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.fields")),Object(l.b)("p",null,"Schema's fields"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Field[]"),": an array of field instances"),Object(l.b)("h4",{id:"schemaforeign_keys"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.foreign_keys")),Object(l.b)("p",null,"Schema's foreign keys"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict[]"),": foreign keys"),Object(l.b)("h4",{id:"schemaheaders"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.headers")),Object(l.b)("p",null,"Schema's field names"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str[]"),": an array of field names"),Object(l.b)("h4",{id:"schemamissing_values"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.missing_values")),Object(l.b)("p",null,"Schema's missing values"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str[]"),": missing values"),Object(l.b)("h4",{id:"schemaprimary_key"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.primary_key")),Object(l.b)("p",null,"Schema's primary keys"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str[]"),": primary keys"),Object(l.b)("h4",{id:"schemavalid"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.valid")),Object(l.b)("p",null,"Validation status"),Object(l.b)("p",null,"Always true in strict mode."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"bool"),": validation status"),Object(l.b)("h4",{id:"schemaget_field"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.get_field")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.get_field(name)\n")),Object(l.b)("p",null,"Get schema's field by name."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"Use ",Object(l.b)("inlineCode",{parentName:"p"},"table.update_field")," if you want to modify the field descriptor")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"name (str)"),": schema field name")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Field/None"),": ",Object(l.b)("inlineCode",{parentName:"p"},"Field")," instance or ",Object(l.b)("inlineCode",{parentName:"p"},"None")," if not found"),Object(l.b)("h4",{id:"schemaget_field-1"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.get_field")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.get_field(name)\n")),Object(l.b)("p",null,"Get schema's field by name."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"Use ",Object(l.b)("inlineCode",{parentName:"p"},"table.update_field")," if you want to modify the field descriptor")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"name (str)"),": schema field name")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Field/None"),": ",Object(l.b)("inlineCode",{parentName:"p"},"Field")," instance or ",Object(l.b)("inlineCode",{parentName:"p"},"None")," if not found"),Object(l.b)("h4",{id:"schemaadd_field"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.add_field")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.add_field(descriptor)\n")),Object(l.b)("p",null,"Add new field to schema."),Object(l.b)("p",null,"The schema descriptor will be validated with newly added field descriptor."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"descriptor (dict)"),": field descriptor")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises any error that occurs during the process")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Field/None"),": added ",Object(l.b)("inlineCode",{parentName:"p"},"Field")," instance or ",Object(l.b)("inlineCode",{parentName:"p"},"None")," if not added"),Object(l.b)("h4",{id:"schemaupdate_field"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.update_field")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.update_field(name, update)\n")),Object(l.b)("p",null,"Update existing descriptor field by name"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"name (str)"),": schema field name"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"update (dict)"),": update to apply to field's descriptor")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"bool"),": true on success and false if no field is found to be modified"),Object(l.b)("h4",{id:"schemaremove_field"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.remove_field")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.remove_field(name)\n")),Object(l.b)("p",null,"Remove field resource by name."),Object(l.b)("p",null,"The schema descriptor will be validated after field descriptor removal."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"name (str)"),": schema field name")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises any error that occurs during the process")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Field/None"),": removed ",Object(l.b)("inlineCode",{parentName:"p"},"Field")," instances or ",Object(l.b)("inlineCode",{parentName:"p"},"None")," if not found"),Object(l.b)("h4",{id:"schemacast_row"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.cast_row")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.cast_row(row, fail_fast=False, row_number=None, exc_handler=None)\n")),Object(l.b)("p",null,"Cast row based on field types and formats."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"row (any[]"),": data row as an array of values")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"any[]"),": returns cast data row"),Object(l.b)("h4",{id:"schemainfer"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.infer")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.infer(rows,\n             headers=1,\n             confidence=0.75,\n             guesser_cls=None,\n             resolver_cls=None)\n")),Object(l.b)("p",null,"Infer and set ",Object(l.b)("inlineCode",{parentName:"p"},"schema.descriptor")," based on data sample."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"rows (list[])"),": array of arrays representing rows."),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"headers (int/str[])"),": data sample headers (one of):",Object(l.b)("pre",{parentName:"li"},Object(l.b)("code",{parentName:"pre"},"- row number containing headers (`rows` should contain headers rows)\n- array of headers (`rows` should NOT contain headers rows)\n"))),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"confidence (float)"),": how many casting errors are allowed (as a ratio, between 0 and 1)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"guesser_cls (class)"),": you can implement inferring strategies by\nproviding type-guessing and type-resolving classes ","[experimental]"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"resolver_cls (class)"),": you can implement inferring strategies by\nproviding type-guessing and type-resolving classes ","[experimental]")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict"),": Table Schema descriptor"),Object(l.b)("h4",{id:"schemacommit"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.commit")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.commit(strict=None)\n")),Object(l.b)("p",null,"Update schema instance if there are in-place changes in the descriptor."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Example")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"from tableschema import Schema\ndescriptor = {'fields': [{'name': 'my_field', 'title': 'My Field', 'type': 'string'}]}\nschema = Schema(descriptor)\nprint(schema.get_field('my_field').descriptor['type']) # string\n\n# Update descriptor by field position\nschema.descriptor['fields'][0]['type'] = 'number'\n# Update descriptor by field name\nschema.update_field('my_field', {'title': 'My Pretty Field'}) # True\n\n# Change are not committed\nprint(schema.get_field('my_field').descriptor['type']) # string\nprint(schema.get_field('my_field').descriptor['title']) # My Field\n\n# Commit change\nschema.commit()\nprint(schema.get_field('my_field').descriptor['type']) # number\nprint(schema.get_field('my_field').descriptor['title']) # My Pretty Field\n\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"strict (bool)"),": alter ",Object(l.b)("inlineCode",{parentName:"li"},"strict")," mode for further work")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises any error that occurs during the process")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"bool"),": true on success and false if not modified"),Object(l.b)("h4",{id:"schemasave"},Object(l.b)("inlineCode",{parentName:"h4"},"schema.save")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"schema.save(target, ensure_ascii=True)\n")),Object(l.b)("p",null,"Save schema descriptor to target destination."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"target (str)"),": path where to save a descriptor")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises any error that occurs during the process")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"bool"),": true on success"),Object(l.b)("h3",{id:"field"},Object(l.b)("inlineCode",{parentName:"h3"},"Field")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"Field(self, descriptor, missing_values=[''], schema=None)\n")),Object(l.b)("p",null,"Field representaion"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"descriptor (dict)"),": schema field descriptor"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"missingValues (str[])"),": an array with string representing missing values")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises any error that occurs during the process")),Object(l.b)("h4",{id:"fieldconstraints"},Object(l.b)("inlineCode",{parentName:"h4"},"field.constraints")),Object(l.b)("p",null,"Field constraints"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict"),": dict of field constraints"),Object(l.b)("h4",{id:"fielddescriptor"},Object(l.b)("inlineCode",{parentName:"h4"},"field.descriptor")),Object(l.b)("p",null,"Fields's descriptor"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict"),": descriptor"),Object(l.b)("h4",{id:"fieldformat"},Object(l.b)("inlineCode",{parentName:"h4"},"field.format")),Object(l.b)("p",null,"Field format"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str"),": field format"),Object(l.b)("h4",{id:"fieldmissing_values"},Object(l.b)("inlineCode",{parentName:"h4"},"field.missing_values")),Object(l.b)("p",null,"Field's missing values"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str[]"),": missing values"),Object(l.b)("h4",{id:"fieldname"},Object(l.b)("inlineCode",{parentName:"h4"},"field.name")),Object(l.b)("p",null,"Field name"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str"),": field name"),Object(l.b)("h4",{id:"fieldrequired"},Object(l.b)("inlineCode",{parentName:"h4"},"field.required")),Object(l.b)("p",null,"Whether field is required"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"bool"),": true if required"),Object(l.b)("h4",{id:"fieldschema"},Object(l.b)("inlineCode",{parentName:"h4"},"field.schema")),Object(l.b)("p",null,"Returns a schema instance if the field belongs to some schema"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Schema"),": field's schema"),Object(l.b)("h4",{id:"fieldtype"},Object(l.b)("inlineCode",{parentName:"h4"},"field.type")),Object(l.b)("p",null,"Field type"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str"),": field type"),Object(l.b)("h4",{id:"fieldcast_value"},Object(l.b)("inlineCode",{parentName:"h4"},"field.cast_value")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"field.cast_value(value, constraints=True)\n")),Object(l.b)("p",null,"Cast given value according to the field type and format."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"value (any)"),": value to cast against field"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"constraints (boll/str[])"),": gets constraints configuration",Object(l.b)("pre",{parentName:"li"},Object(l.b)("code",{parentName:"pre"},"  - it could be set to true to disable constraint checks\n  - it could be an Array of constraints to check e.g. ['minimum', 'maximum']\n")))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises any error that occurs during the process")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"any"),": returns cast value"),Object(l.b)("h4",{id:"fieldtest_value"},Object(l.b)("inlineCode",{parentName:"h4"},"field.test_value")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"field.test_value(value, constraints=True)\n")),Object(l.b)("p",null,"Test whether value is compliant to the field."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"value (any)"),": value to cast against field"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"constraints (bool/str[])"),": constraints configuration")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"bool"),": returns if value is compliant to the field"),Object(l.b)("h3",{id:"storage"},Object(l.b)("inlineCode",{parentName:"h3"},"Storage")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"Storage(self, **options)\n")),Object(l.b)("p",null,"Storage factory/interface"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"For users")),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"Use ",Object(l.b)("inlineCode",{parentName:"p"},"Storage.connect")," to instantiate a storage")),Object(l.b)("p",null,"For instantiation of concrete storage instances,\n",Object(l.b)("inlineCode",{parentName:"p"},"tableschema.Storage")," provides a unified factory method ",Object(l.b)("inlineCode",{parentName:"p"},"connect"),"\n(which uses the plugin system under the hood):"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"# pip install tableschema_sql\nfrom tableschema import Storage\n\nstorage = Storage.connect('sql', **options)\nstorage.create('bucket', descriptor)\nstorage.write('bucket', rows)\nstorage.read('bucket')\n")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"For integrators")),Object(l.b)("p",null,"The library includes interface declaration to implement tabular ",Object(l.b)("inlineCode",{parentName:"p"},"Storage"),".\nThis interface allow to use different data storage systems like SQL\nwith ",Object(l.b)("inlineCode",{parentName:"p"},"tableschema.Table")," class (load/save) as well as on the data package level:"),Object(l.b)("p",null,Object(l.b)("img",{parentName:"p",src:"https://raw.githubusercontent.com/frictionlessdata/tableschema-py/master/data/storage.png",alt:"Storage"})),Object(l.b)("p",null,"An implementor must follow ",Object(l.b)("inlineCode",{parentName:"p"},"tableschema.Storage")," interface\nto write his own storage backend. Concrete storage backends\ncould include additional functionality specific to conrete storage system.\nSee ",Object(l.b)("inlineCode",{parentName:"p"},"plugins")," below to know how to integrate custom storage plugin into your workflow."),Object(l.b)("h4",{id:"storagebuckets"},Object(l.b)("inlineCode",{parentName:"h4"},"storage.buckets")),Object(l.b)("p",null,"Return list of storage bucket names."),Object(l.b)("p",null,"A ",Object(l.b)("inlineCode",{parentName:"p"},"bucket")," is a special term which has almost the same meaning as ",Object(l.b)("inlineCode",{parentName:"p"},"table"),".\nYou should consider ",Object(l.b)("inlineCode",{parentName:"p"},"bucket")," as a ",Object(l.b)("inlineCode",{parentName:"p"},"table")," stored in the ",Object(l.b)("inlineCode",{parentName:"p"},"storage"),"."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"exceptions.StorageError"),": raises on any error")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"str[]"),": return list of bucket names"),Object(l.b)("h4",{id:"storageconnect"},Object(l.b)("inlineCode",{parentName:"h4"},"storage.connect")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"storage.connect(name, **options)\n")),Object(l.b)("p",null,"Create tabular ",Object(l.b)("inlineCode",{parentName:"p"},"storage")," based on storage name."),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"This method is statis: ",Object(l.b)("inlineCode",{parentName:"p"},"Storage.connect()"))),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"name (str)"),": storage name like ",Object(l.b)("inlineCode",{parentName:"li"},"sql")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"options (dict)"),": concrete storage options")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"StorageError"),": raises on any error")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"Storage"),": returns ",Object(l.b)("inlineCode",{parentName:"p"},"Storage")," instance"),Object(l.b)("h4",{id:"storagecreate"},Object(l.b)("inlineCode",{parentName:"h4"},"storage.create")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"storage.create(bucket, descriptor, force=False)\n")),Object(l.b)("p",null,"Create one/multiple buckets."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"bucket (str/list)"),": bucket name or list of bucket names"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"descriptor (dict/dict[])"),": schema descriptor or list of descriptors"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"force (bool)"),": whether to delete and re-create already existing buckets")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"exceptions.StorageError"),": raises on any error")),Object(l.b)("h4",{id:"storagedelete"},Object(l.b)("inlineCode",{parentName:"h4"},"storage.delete")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"storage.delete(bucket=None, ignore=False)\n")),Object(l.b)("p",null,"Delete one/multiple/all buckets."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"bucket (str/list/None)"),": bucket name or list of bucket names to delete.\nIf ",Object(l.b)("inlineCode",{parentName:"li"},"None"),", all buckets will be deleted"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"descriptor (dict/dict[])"),": schema descriptor or list of descriptors"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"ignore (bool)"),": don't raise an error on non-existent bucket deletion")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"exceptions.StorageError"),": raises on any error")),Object(l.b)("h4",{id:"storagedescribe"},Object(l.b)("inlineCode",{parentName:"h4"},"storage.describe")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"storage.describe(bucket, descriptor=None)\n")),Object(l.b)("p",null,"Get/set bucket's Table Schema descriptor"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"bucket (str)"),": bucket name"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"descriptor (dict/None)"),": schema descriptor to set")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"exceptions.StorageError"),": raises on any error")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict"),": returns Table Schema descriptor"),Object(l.b)("h4",{id:"storageiter"},Object(l.b)("inlineCode",{parentName:"h4"},"storage.iter")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"storage.iter(bucket)\n")),Object(l.b)("p",null,"Return an iterator of typed values based on the schema of this bucket."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"bucket (str)"),": bucket name")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"exceptions.StorageError"),": raises on any error")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"list[]"),": yields data rows"),Object(l.b)("h4",{id:"storageread"},Object(l.b)("inlineCode",{parentName:"h4"},"storage.read")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"storage.read(bucket)\n")),Object(l.b)("p",null,"Read typed values based on the schema of this bucket."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"bucket (str)"),": bucket name\n",Object(l.b)("strong",{parentName:"li"},"Raises")),Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"exceptions.StorageError"),": raises on any error\n",Object(l.b)("strong",{parentName:"li"},"Returns"))),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"list[]"),": returns data rows"),Object(l.b)("h4",{id:"storagewrite"},Object(l.b)("inlineCode",{parentName:"h4"},"storage.write")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"storage.write(bucket, rows)\n")),Object(l.b)("p",null,"This method writes data rows into ",Object(l.b)("inlineCode",{parentName:"p"},"storage"),"."),Object(l.b)("p",null,"It should store values of unsupported types as strings internally (like csv does)."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"bucket (str)"),": bucket name"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"rows (list[])"),": data rows to write")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"exceptions.StorageError"),": raises on any error")),Object(l.b)("h3",{id:"validate"},Object(l.b)("inlineCode",{parentName:"h3"},"validate")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"validate(descriptor)\n")),Object(l.b)("p",null,"Validate descriptor"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"dict"),": descriptor")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"ValidationError"),": on validation errors")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"bool"),": True"),Object(l.b)("h3",{id:"infer"},Object(l.b)("inlineCode",{parentName:"h3"},"infer")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"infer(source,\n      headers=1,\n      limit=100,\n      confidence=0.75,\n      missing_values=[''],\n      guesser_cls=None,\n      resolver_cls=None,\n      **options)\n")),Object(l.b)("p",null,"Infer source schema."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"source (any)"),": source as path, url or inline data"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"headers (int/str[])"),": headers rows number or headers list"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"confidence (float)"),": how many casting errors are allowed (as a ratio, between 0 and 1)"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"missing_values (str[])"),": list of missing values (by default ",Object(l.b)("inlineCode",{parentName:"li"},"['']"),")"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"guesser_cls (class)"),": you can implement inferring strategies by\nproviding type-guessing and type-resolving classes ","[experimental]"),Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"resolver_cls (class)"),": you can implement inferring strategies by\nproviding type-guessing and type-resolving classes ","[experimental]")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Raises")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("inlineCode",{parentName:"li"},"TableSchemaException"),": raises any error that occurs during the process")),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"dict"),": returns schema descriptor"),Object(l.b)("h3",{id:"failedcast"},Object(l.b)("inlineCode",{parentName:"h3"},"FailedCast")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"FailedCast(self, value)\n")),Object(l.b)("p",null,"Wrap an original data field value that failed to be properly casted."),Object(l.b)("p",null,"FailedCast allows for further processing/yielding values but still be able\nto distinguish uncasted values on the consuming side."),Object(l.b)("p",null,"Delegates attribute access and the basic rich comparison methods to the\nunderlying object. Supports default user-defined classes hashability i.e.\nis hashable based on object identity (not based on the wrapped value)."),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Arguments")),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},Object(l.b)("strong",{parentName:"li"},"value (any)"),": value")),Object(l.b)("h3",{id:"datapackageexception"},Object(l.b)("inlineCode",{parentName:"h3"},"DataPackageException")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"DataPackageException(self, message, errors=[])\n")),Object(l.b)("p",null,"Base class for all DataPackage/TableSchema exceptions."),Object(l.b)("p",null,"If there are multiple errors, they can be read from the exception object:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"try:\n    # lib action\nexcept DataPackageException as exception:\n    if exception.multiple:\n        for error in exception.errors:\n            # handle error\n")),Object(l.b)("h4",{id:"datapackageexceptionerrors"},Object(l.b)("inlineCode",{parentName:"h4"},"datapackageexception.errors")),Object(l.b)("p",null,"List of nested errors"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"DataPackageException[]"),": list of nested errors"),Object(l.b)("h4",{id:"datapackageexceptionmultiple"},Object(l.b)("inlineCode",{parentName:"h4"},"datapackageexception.multiple")),Object(l.b)("p",null,"Whether it's a nested exception"),Object(l.b)("p",null,Object(l.b)("strong",{parentName:"p"},"Returns")),Object(l.b)("p",null,Object(l.b)("inlineCode",{parentName:"p"},"bool"),": whether it's a nested exception"),Object(l.b)("h3",{id:"tableschemaexception"},Object(l.b)("inlineCode",{parentName:"h3"},"TableSchemaException")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"TableSchemaException(self, message, errors=[])\n")),Object(l.b)("p",null,"Base class for all TableSchema exceptions."),Object(l.b)("h3",{id:"loaderror"},Object(l.b)("inlineCode",{parentName:"h3"},"LoadError")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"LoadError(self, message, errors=[])\n")),Object(l.b)("p",null,"All loading errors."),Object(l.b)("h3",{id:"validationerror"},Object(l.b)("inlineCode",{parentName:"h3"},"ValidationError")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"ValidationError(self, message, errors=[])\n")),Object(l.b)("p",null,"All validation errors."),Object(l.b)("h3",{id:"casterror"},Object(l.b)("inlineCode",{parentName:"h3"},"CastError")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"CastError(self, message, errors=[])\n")),Object(l.b)("p",null,"All value cast errors."),Object(l.b)("h3",{id:"integrityerror"},Object(l.b)("inlineCode",{parentName:"h3"},"IntegrityError")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"IntegrityError(self, message, errors=[])\n")),Object(l.b)("p",null,"All integrity errors."),Object(l.b)("h3",{id:"uniquekeyerror"},Object(l.b)("inlineCode",{parentName:"h3"},"UniqueKeyError")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"UniqueKeyError(self, message, errors=[])\n")),Object(l.b)("p",null,"Unique key constraint violation (CastError subclass)"),Object(l.b)("h3",{id:"relationerror"},Object(l.b)("inlineCode",{parentName:"h3"},"RelationError")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"RelationError(self, message, errors=[])\n")),Object(l.b)("p",null,"All relations errors."),Object(l.b)("h3",{id:"unresolvedfkerror"},Object(l.b)("inlineCode",{parentName:"h3"},"UnresolvedFKError")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"UnresolvedFKError(self, message, errors=[])\n")),Object(l.b)("p",null,"Unresolved foreign key reference error (RelationError subclass)."),Object(l.b)("h3",{id:"storageerror"},Object(l.b)("inlineCode",{parentName:"h3"},"StorageError")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"StorageError(self, message, errors=[])\n")),Object(l.b)("p",null,"All storage errors."),Object(l.b)("h2",{id:"experimental"},"Experimental"),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"This API is experimental and can be changed/removed in the future")),Object(l.b)("p",null,"There is an experimental environment variable ",Object(l.b)("inlineCode",{parentName:"p"},"TABLESCHEMA_PRESERVE_MISSING_VALUES")," which, if it is set, affects how data casting works."),Object(l.b)("p",null,"By default, missing values are resolved to ",Object(l.b)("inlineCode",{parentName:"p"},"None")," values. When this flag is set, missing values are passed through as it is. For example:"),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"missing_values.py")),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-python"},"from tableschema import Field\n\nfield = Field({'type': 'number'}, missing_values=['-'])\nprint(field.cast_value('3'))\nprint(field.cast_value('-'))\n")),Object(l.b)("p",null,"Running this script in different modes:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-bash"},"$ python missing_values.py\n3\nNone\n$ TABLESCHEMA_PRESERVE_MISSING_VALUES=1 python missing_values.py\n3\n-\n")),Object(l.b)("p",null,"The flags affects all the library's APIs and software built on top of ",Object(l.b)("inlineCode",{parentName:"p"},"tableschema"),". For example, Data Package Pipelines:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-bash"},"$ TABLESCHEMA_PRESERVE_MISSING_VALUES=1 dpp run ./my_pipeline\n")),Object(l.b)("h2",{id:"contributing"},"Contributing"),Object(l.b)("blockquote",null,Object(l.b)("p",{parentName:"blockquote"},"The project follows the ",Object(l.b)("a",{parentName:"p",href:"https://github.com/okfn/coding-standards"},"Open Knowledge International coding standards"),".")),Object(l.b)("p",null,"Recommended way to get started is to create and activate a project virtual environment.\nTo install package and development dependencies into active environment:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-bash"},"$ make install\n")),Object(l.b)("p",null,"To run tests with linting and coverage:"),Object(l.b)("pre",null,Object(l.b)("code",{parentName:"pre",className:"language-bash"},"$ make test\n")),Object(l.b)("h2",{id:"changelog"},"Changelog"),Object(l.b)("p",null,"Here described only breaking and the most important changes. The full changelog and documentation for all released versions can be found in the nicely formatted ",Object(l.b)("a",{parentName:"p",href:"https://github.com/frictionlessdata/tableschema-py/commits/master"},"commit history"),"."),Object(l.b)("h4",{id:"v120"},"v1.20"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added --json flag to the CLI (#287)")),Object(l.b)("h4",{id:"v119"},"v1.19"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Deduplicate field names if guessing in infer")),Object(l.b)("h4",{id:"v118"},"v1.18"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Publish ",Object(l.b)("inlineCode",{parentName:"li"},"field.ERROR/cast_function/check_functions"))),Object(l.b)("h4",{id:"v117"},"v1.17"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added ",Object(l.b)("inlineCode",{parentName:"li"},"schema.missing_values")," and ",Object(l.b)("inlineCode",{parentName:"li"},"field.missing_values"))),Object(l.b)("h4",{id:"v116"},"v1.16"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Fixed the way we parse ",Object(l.b)("inlineCode",{parentName:"li"},"geopoint"),":",Object(l.b)("ul",{parentName:"li"},Object(l.b)("li",{parentName:"ul"},'as a string it can be in 3 forms ("default", "array", "object") BUT'),Object(l.b)("li",{parentName:"ul"},"as native object it can only be a list/tuple")))),Object(l.b)("h4",{id:"v115"},"v1.15"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added an experimental ",Object(l.b)("inlineCode",{parentName:"li"},"TABLESCHEMA_PRESERVE_MISSING_VALUES")," environment variable flag")),Object(l.b)("h4",{id:"v114"},"v1.14"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Allow providing custom guesser and resolver to ",Object(l.b)("inlineCode",{parentName:"li"},"table.infer")," and ",Object(l.b)("inlineCode",{parentName:"li"},"infer"))),Object(l.b)("h4",{id:"v113"},"v1.13"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added ",Object(l.b)("inlineCode",{parentName:"li"},"missing_values")," argument to the ",Object(l.b)("inlineCode",{parentName:"li"},"infer")," function (#269)")),Object(l.b)("h4",{id:"v112"},"v1.12"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Support optional custom exception handling for table.iter/read (#259)")),Object(l.b)("h4",{id:"v111"},"v1.11"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added ",Object(l.b)("inlineCode",{parentName:"li"},"preserve_missing_values")," parameter to ",Object(l.b)("inlineCode",{parentName:"li"},"field.cast_value"))),Object(l.b)("h4",{id:"v110"},"v1.10"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added an ability to check table's integrity while reading")),Object(l.b)("h4",{id:"v19"},"v1.9"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Implemented the ",Object(l.b)("inlineCode",{parentName:"li"},"table.size")," and ",Object(l.b)("inlineCode",{parentName:"li"},"table.hash")," properties")),Object(l.b)("h4",{id:"v18"},"v1.8"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added ",Object(l.b)("inlineCode",{parentName:"li"},"table.index_foreign_keys_values")," and improved foreign key checks performance")),Object(l.b)("h4",{id:"v17"},"v1.7"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added ",Object(l.b)("inlineCode",{parentName:"li"},"field.schema")," property")),Object(l.b)("h4",{id:"v16"},"v1.6"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"In ",Object(l.b)("inlineCode",{parentName:"li"},"strict")," mode raise an exception if there are problems in field construction")),Object(l.b)("h4",{id:"v15"},"v1.5"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Allow providing custom guesser and resolver to schema infer")),Object(l.b)("h4",{id:"v14"},"v1.4"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added ",Object(l.b)("inlineCode",{parentName:"li"},"schema.update_field")," method")),Object(l.b)("h4",{id:"v13"},"v1.3"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Support datetime with no time for date casting")),Object(l.b)("h4",{id:"v12"},"v1.2"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Support floats like 1.0 for integer casting")),Object(l.b)("h4",{id:"v11"},"v1.1"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"Added the ",Object(l.b)("inlineCode",{parentName:"li"},"confidence")," parameter to ",Object(l.b)("inlineCode",{parentName:"li"},"infer"))),Object(l.b)("h4",{id:"v10"},"v1.0"),Object(l.b)("ul",null,Object(l.b)("li",{parentName:"ul"},"The library has been rebased on the Frictionless Data specs v1 - ",Object(l.b)("a",{parentName:"li",href:"https://frictionlessdata.io/specs/table-schema/"},"https://frictionlessdata.io/specs/table-schema/"))))}p.isMDXComponent=!0}}]);